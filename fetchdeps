#!/usr/bin/env bash
set -euo pipefail
IFS=$' '

readonly FETCHDEPS_VERSION="0.0.0"
readonly DEPS_FILE_FORMAT="deps_name: repository@version"

readonly UPGRADEFILE_DEFAULT="fetchdeps.upgrade.txt"
readonly INSTALLFILE_DEFAULT="fetchdeps.install.txt"
readonly DEPSFOLDER_DEFAULT="deps"

readonly DEPS_UPGRADE=${FETCHDEPS_UPGRADE_FILE:-${UPGRADEFILE_DEFAULT}}
readonly DEPS_INSTALL=${FETCHDEPS_INSTALL_FILE:-${INSTALLFILE_DEFAULT}}
readonly DEPS_FOLDER=${FETCHDEPS_DEPS_FOLDER:-${DEPSFOLDER_DEFAULT}}

readonly DEPS_PERDEP_INSTALLED_FILE=fetchdeps.installed.txt

usage() {
	echo
	echo "Usage: [ENV] ${0} <command> [OPTION]"
	echo
	echo "where <command> is one of:"
	echo -e "\tinstall \t Fetches all the dependencies from '${DEPS_INSTALL}' in '${DEPS_FOLDER}' folder."
	echo -e "\t\t\t   You will want to run this command after a fresh clone or after pulling changes from the repository"
	echo -e "\ti \t\t Alias of <install>"
	echo -e "\tupgrade \t Removes '${DEPS_FOLDER}', fetches all the dependencies from '${DEPS_UPGRADE}' and generates '${DEPS_INSTALL}'"
	echo -e "\t\t\t   Running this command will upgrade dependencies to a newer version if available"
	echo -e "\t\t\t   You should not do run this command in your build process, use <install> instead"
#	echo -e "\tadd NAME URI \t Adds 'NAME' dependency with 'URI' location to '${DEPS_UPGRADE}'"
#	echo -e "\tremove NAME \t Removes 'NAME' dependency from '${DEPS_UPGRADE}'"
#	echo -e "\tlist \t\t Lists all the dependencies"
	echo -e "\tversion \t Shows the current version of this program"
	echo -e "\thelp \t\t Shows the help"
	echo
	echo "where [ENV] are the following environment variables:"
	echo -e "\tFETCHDEPS_INSTALL_FILE=file \t Specifies the file readed during <install>"
	echo -e "\t\t\t\t\t (default: FETCHDEPS_INSTALL_FILE=${INSTALLFILE_DEFAULT})"
	echo -e "\tFETCHDEPS_UPGRADE_FILE=file \t Specifies the file readed during <upgrade>"
	echo -e "\t\t\t\t\t (default: FETCHDEPS_UPGRADE_FILE=${UPGRADEFILE_DEFAULT})"
	echo -e "\tFETCHDEPS_DEPS_FOLDER=folder \t Specifies the folder where all the dependencies will be downloaded"
	echo -e "\t\t\t\t\t (default: FETCHDEPS_DEPS_FOLDER=${DEPSFOLDER_DEFAULT})"
	echo
	echo "where [OPTION] is one of:"
	echo -e "\t-f \t Will stop asking for user confirmation when there is at action that removes folders under '${DEPS_FOLDER}'"
	echo
}

FORCE=0
confirm() {
	if [[ $FORCE = 1 ]] ; then
		return 0
	fi
	echo "${1:-}"
	read -r -p "Are you sure? [y/N] (Use option -f to avoid this question)" response < /dev/tty
	case $response in
	    [yY][eE][sS]|[yY]) 
	        return 0
	        ;;
	    *)
	        throw "Aborted"
	        ;;
	esac
}

throw() {
	echo "ERROR: $@" 1>&2
	exit 1
}

confirm_wipe() {
	confirm "This action will wipe completely the following folder: $1"
}

install_all() {
	(
		mkdir -p ${DEPS_FOLDER}
		cd ${DEPS_FOLDER}
		echo "Installing on $(pwd)" 1>&2

		if [[ ! -f ../${DEPS_INSTALL} ]] ; then
			throw "'${0} install' needs a ${DEPS_INSTALL} file in the current folder"
		fi

		echo "Reading ${DEPS_INSTALL}" 1>&2
		DEPS=$(cat ../${DEPS_INSTALL})

		echo "$DEPS" | install_deps
	)
}

git_install() {
	local repository="$1"
	local commit_id=""
	{
		git clone $repository .
		git reset --hard $version
		commit_id=$(git rev-parse HEAD)
		rm -rf .git
	} 2>> ../git-stderr.log 1>> ../git-stdout.log
	echo $commit_id
}

get_installed_version() {
	local repository=$1
	local commit_id=$2
	echo "${1}@${2}"
}

install_single_dep() {
	local folder=$1
	local repository=$2
	local version=$3

	local installed_file=${folder}/${DEPS_PERDEP_INSTALLED_FILE}
	local installed_version=$(get_installed_version $repository $version)

	if [[ -d ${folder} ]] && [[ -f ${installed_file} ]] && [[ $(cat ${installed_file}) = $installed_version ]]; then
		echo -e "Ignoring: ${folder}\t(already installed)"
	else
	(
		echo -ne "Fetching: ${folder}"
		if [[ -d $folder ]]; then
			echo
			echo
			echo "For installing a new version of '${folder}', the old one needs to be deleted first"
			confirm_wipe "$(cd $folder; pwd)"
			echo
			rm -rf $folder > /dev/null 2>&1
		fi
		mkdir $folder
		cd $folder

		echo "$(get_installed_version $repository $(git_install $repository))" > ${DEPS_PERDEP_INSTALLED_FILE}
		echo -e "\tOK -> $(pwd)"
	)
	fi
}

throw_format() {
	throw "Line $1 '$dep' does not follow the format '$DEPS_FILE_FORMAT'"
}

install_deps() {
	local i=$((0))
	while read -r dep ; do

		if [[ $dep =~ ^([^[:space:]]+*)\:\ ([^[:space:]]+*)@([^[:space:]]+*)$ ]] ; then
			install_single_dep "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}" "${BASH_REMATCH[3]}"
		else
			throw_format $i
		fi

		i=$((i + 1))
	done
}

upgrade_deps() {
	rm ../${DEPS_INSTALL} 2> /dev/null || true
	while read -r folder ; do
		folder=${folder//\/}
		local installed_version=$(cat ${folder}/${DEPS_PERDEP_INSTALLED_FILE})
		echo "${folder}: ${installed_version}" >> ../${DEPS_INSTALL}
	done
	echo "Generated: ${DEPS_INSTALL} (this file should be under version control)"
}

upgrade_all() {
	(
		if [[ ! -f ${DEPS_UPGRADE} ]] ; then
			throw "'${0} upgrade' needs a ${DEPS_UPGRADE} file in the current folder"
		fi

		if [[ -d ${DEPS_FOLDER} ]] ; then
			echo
			echo "For upgrading dependencies, the old ones under '${DEPS_FOLDER}' need to be deleted first"
			confirm_wipe "$(pwd)/${DEPS_FOLDER}"
			echo
			rm -r ${DEPS_FOLDER}
		fi
		mkdir -p ${DEPS_FOLDER}
		cd ${DEPS_FOLDER}
		echo "Installing on $(pwd)" 1>&2

		echo "Reading ${DEPS_UPGRADE}" 1>&2
		local DEPS=$(cat ../${DEPS_UPGRADE})

		echo "$DEPS" | install_deps
		ls -d */ | upgrade_deps
	)
}

if [[ "${BASH_SOURCE[0]}" = "${0}" ]] ; then

	command="${1:-}"

	while getopts :f option; do
	    case $option in
	        f)
	       		FORCE=1
	       		;;     
	        \?)
	            usage
	            throw "Wrong option [$@]"
	            ;;
    	esac
	done

	case $command in
		i)
		    	;&
		install)
			install_all
			;;
		upgrade)
			upgrade_all
			;;
		version)
			echo "${FETCHDEPS_VERSION}"
			;;
		help)
			echo
			echo "FETCHDEPS VERSION: ${FETCHDEPS_VERSION}"
			usage
			echo "Example:"
			echo -e "\t- $0 install"
			echo
			;;
		*)
			usage
			if [[ "$@" == "" ]]; then
				throw "Missing command"
			fi
			throw "Wrong command '$@'"
			;;
	esac
fi
